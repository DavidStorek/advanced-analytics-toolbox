{"version":3,"sources":["advanced-analytics-toolbox.js"],"names":["define","qlik","$","cssContent","props","initialProps","ngTemplate","ui","analysis","utils","html","appendTo","createChart","$scope","$compile","app","visualization","layout","selectedAnalysisType","analysisTypes","filter","d","id","analysisTypeId","require","file","hyperCubeCreator","createCube","isMinDimAndMeaUnmet","dimCount","dimensions","length","meaCount","measures","effectiveMinMeas","customMinMeas","minMeas","minDims","i","expression","qStringExpression","checkPreconditions","callback1","callback2","callback3","layoutProps","analysisCategoryId","initialProperties","definition","support","snapshot","export","exportData","template","controller","currApp","undefined","extId","qInfo","qId","patchApplied","chart","setLocaleInfo","compile","$watch","a","b","c","screen","paint","$element","_this","this","self","mode","navigation","getMode","incomplete","_$scope","_$compile","_app","createHtmlElements","drawChart","then","Promise","resolve"],"mappings":"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","file":"../../advanced-analytics-toolbox.js","sourcesContent":["define([\n  'qlik',\n  'jquery',\n  'css!./lib/css/styles.css',\n  './properties',\n  './initialProperties',\n  'text!./advanced-analytics-toolbox.ng.html',\n  './lib/js/ui/ui_control',\n  './lib/js/analysis/analysis',\n  './lib/js/util/utils',\n], (qlik, $, cssContent, props, initialProps, ngTemplate, ui, analysis, utils) => {\n  // Set style sheet\n  $('<style>').html(cssContent).appendTo('head');\n\n  /**\n   * createChart - call createCube function based on the selected analysis type\n   *\n   * @param {Object} $scope   angular $scope\n   * @param {Object} $compile angular $compile\n   * @param {Object} app      reference to app\n   *\n   * @return {Null} null\n   */\n  const createChart = ($scope, $compile, app) => {\n    const visualization = $scope.layout.visualization;\n\n    const selectedAnalysisType = analysis.analysisTypes.filter((d) => {\n      return d.id === $scope.layout.props.analysisTypeId;\n    });\n    require([`./extensions/${visualization}/lib/js/analysis/${selectedAnalysisType[0].file}`], (hyperCubeCreator) => {\n      hyperCubeCreator.createCube(app, $scope);\n    });\n    return null;\n  };\n\n  /**\n   * isMinDimAndMeaUnmet - check the number of dimensions and measures\n   *                       required for the selected chart type.\n   *\n   * @param {Object} $scope angular $scope\n   *\n   * @return {Boolean} Return true if minimum number of dimensions and measures\n   *                required for the selected chart type is not met.\n   */\n  const isMinDimAndMeaUnmet = ($scope) => {\n    // Set number of current dim and mea count\n    const dimCount = $scope.layout.props.dimensions.length;\n    const meaCount = $scope.layout.props.measures.length;\n\n    // Filter the selected analysis type\n    const selectedAnalysisType = analysis.analysisTypes.filter((d) => {\n      return d.id === $scope.layout.props.analysisTypeId;\n    });\n\n    // When customMinMeas is set, set it as an effective Minumum Measures count value.\n    const effectiveMinMeas = (typeof $scope.customMinMeas == 'undefined' || typeof $scope.customMinMeas[$scope.layout.props.analysisTypeId] == 'undefined') ? selectedAnalysisType[0].minMeas : $scope.customMinMeas[$scope.layout.props.analysisTypeId];\n\n    if (\n      selectedAnalysisType[0].minDims > dimCount ||\n      effectiveMinMeas > meaCount\n    ) {\n      return true;\n    }\n\n    for (let i = 0; i < dimCount; i++) {\n      if (typeof $scope.layout.props.dimensions[i].expression.qStringExpression == 'undefined' && $scope.layout.props.dimensions[i].expression === '') { return true; }\n    }\n\n    for (let i = 0; i < meaCount; i++) {\n      if (typeof $scope.layout.props.measures[i].expression.qStringExpression == 'undefined' && $scope.layout.props.measures[i].expression === '') { return true; }\n    }\n    return false;\n  };\n\n  /**\n   * checkPreconditions - Check precondition for rendering charts.\n   *\n   * @param {Object} $scope    angular $scope\n   * @param {Object} $compile  angular $compile\n   * @param {Object} app       reference to app\n   * @param {Object} callback1 called when analysis category and type is not selected.\n   * @param {Object} callback2 called when requirement for minumum dimension and measure is not met.\n   * @param {Object} callback3 called when all requirements for chart rendering is met\n   *\n   * @return {Null} null\n   */\n  const checkPreconditions = ($scope, $compile, app, callback1, callback2, callback3) => {\n    const layoutProps = $scope.layout.props;\n    if (layoutProps.analysisCategoryId === -1 || layoutProps.analysisTypeId === -1) {\n      callback1($scope, $compile, app);\n    } else if (isMinDimAndMeaUnmet($scope)) {\n      callback2($scope, $compile, app);\n    } else {\n      callback3($scope, $compile, app);\n    }\n    return null;\n  };\n\n  return {\n    initialProperties: initialProps,\n    definition: props,\n    support: {\n      snapshot: true,\n      export: false,\n      exportData: true,\n    },\n    template: ngTemplate,\n    // Controller\n    controller: ['$scope', '$compile', ($scope, $compile) => {\n      // Get a reference to app\n      const app = qlik.currApp(this);\n\n      // Set extension id\n      $scope.extId = $scope.layout.qInfo.qId;\n\n      // Set patch applied flat.\n      $scope.patchApplied = false;\n\n      // Create variable to store chart\n      $scope.chart = [];\n\n      // Get number format (thousand separators, decimal separators, etc) from locale info\n      utils.setLocaleInfo($scope, app);\n\n      // Store $compile under $scope to be accessible from paint method\n      $scope.compile = $compile;\n\n      // Watch the change of the settings on property panel\n      $scope.$watch('layout.props', (layoutProps) => {\n        checkPreconditions(\n          $scope, $compile, app,\n          (a, b, c) => {\n            $scope.screen = 0;\n            // create HTML is called in paint\n            // ui.createHtmlElements(a, b, c);\n          },\n          (a, b, c) => {\n            $scope.screen = 1;\n            // create HTML is called in paint\n            // ui.createHtmlElements(a, b, c);\n          },\n          (a, b, c) => {\n            createChart(a, b, c);\n          },\n        );\n      }, true);\n    }],\n    // Paint\n    paint($element, layout) {\n      // Get a reference to app\n      const app = qlik.currApp(this);\n\n      this.$scope.self = this;\n\n      // Set a flag to display 'Incomplete visualization' in 'analysis' mode.\n      // In 'edit' mode, a chart or buttons for settings are displayed.\n      const mode = qlik.navigation.getMode();\n      if (mode === 'analysis') {\n        this.$scope.incomplete = true;\n      } else {\n        this.$scope.incomplete = false;\n      }\n\n      // Create HTML element when analysis category and type is not selected,\n      // or when min dim and mea requirements are not met.\n      checkPreconditions(\n        this.$scope, this.$scope.compile, app,\n        (_$scope, _$compile, _app) =>  {\n          this.$scope.screen = 0;\n          ui.createHtmlElements(_$scope, _$compile, _app);\n        },\n        (_$scope, _$compile, _app) =>  {\n          this.$scope.screen = 1;\n          ui.createHtmlElements(_$scope, _$compile, _app);\n        },\n        () => {}, // Ignore when a chart is displayed\n      );\n\n      // drawChart is called only when patchApplied flag is true to avoid called\n      // twice: initial paint call and paint method called when patch applied.\n      // Leave the flag true after initial call because paint method is called\n      // when record selections and drawChart need to be called.\n      if (this.$scope.patchApplied) {\n        // Retrieve updated data and redraw the chart with the data\n        checkPreconditions(\n          this.$scope, this.$compile, app,\n          () => {}, // Ignore when analysis category and type is not selected.\n          () => {}, // Ignore when min dim and mea requirements are not met.\n          (_$scope, _$compile, _app) => {\n            const visualization = _$scope.layout.visualization;\n\n            // Filter the selected analysis type\n            const selectedAnalysisType = analysis.analysisTypes.filter((d) => {\n              return d.id === _$scope.layout.props.analysisTypeId;\n            });\n            require([`./extensions/${visualization}/lib/js/analysis/${selectedAnalysisType[0].file}`], (hyperCubeCreator) => {\n              hyperCubeCreator.drawChart(_$scope, _app).then(() => {\n                return qlik.Promise.resolve();\n              });\n            });\n          },\n        );\n      } // end of if\n    },\n  };\n});\n"]}